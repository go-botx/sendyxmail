# Бот SendyXMail для платформы eXpress

Бот предоставляет API для отправки личных и групповых сообщений пользователям CTS сервера, используя email-адреса.

## Работа с API

### Конечные точки API

* `POST /api/v0/message` - отправить боту сообщение для дальнейшей пересылки в определенный чат, без ожидания успешности операции доставки. В случае успеха, получаем ответ `202 Accepted`.
* `POST /api/v0/message/with-status` - Отправить боту сообщение для дальнейшей пересылки в определенный чат, с ожиданием успешности доставки до чата. В случае успеха, возвращается `201 Created`.

### Аутентификация в API

Аутентификация происходит токенами "на предъявителя": `Authorization: Bearer <значение>`. Токены запрашиваются у администраторов бота.

### Структура запроса

В теле запроса должен присутствовать единственный объект JSON следующей структуры:

* `to` string | **Обязательный** | Адрес получателя, похожий на e-mail адрес.
  * Если адрес заканчивается на `@chat-id.internal`, то часть перед `@` воспринимается как идентификатор существующего чата.
  * Иначе бот попытается найти пользователя с указанным адресом почты и отправить сообщение ему.
* `body` string | **Обязательный** | Текстовое содержимое сообщения.
* `buttons` array\[\_\]\[\_\] | **Опциональный** | Кнопки под сообщением. Это двумерный массив, где первое измерение представляет массив строк, а второе - сами строки - массив объектов **кнопок**.

**Кнопки** описываются как объекты:

* `label` string | **Обязательный** |
  Текст, который отображается на кнопке.

* `link` string (url) | **Опциональный** | Если заполнено, то при клике на кнопку, бот предложит открыть указанную сылку. Появится сообщение о подтверждении.

* `alert_text` string | **Опциональный** | При клике на кноппу с установленным `link`, данный текст будет отображен в заголовке сообщения о подтверждении.

* `h_size` int | **Опциональный** | Пропорциональный горизонтальный размер кнопки
Значение по-умолчанию `1`. Считается в долях от суммы долей кнопок в строке.
Например, если в одной строке расположены две кнопки с `h_size = 3` и `h_size = 12`, то кнопка с `h_size = 12` будет занимать `12` долей из `15`, то есть `80%` ширины строки.

* `text_color` string | **Опциональный** | Цвет текста на кнопке в формате rgb-hex с обязательной предшествующей решеткой (`#aabb00`)

* `background_color` string | **Опциональный** | Цвет фона кнопки в формате rgb-hex с обязательной предшествующей решеткой (`#aabb00`)

* `text_align` string | **Опциональный** | Выравнивание текста на кнопке. Возможные значения: `left`, `center`, `right`

### Пример отправки сообщения

Пример отправки сообщения на PowerShell 5.1 смотри в [example_send_message.ps1](scripts/example_send_message.ps1). Пример JSON можно посмотреть в [example_json.json](scripts/example_json.json)

### Как отправить сообщение в групповой чат или канал?

Бот должен быть добавлен в групповой чат и иметь возможность отправлять туда сообщения.
Для отправки сообщений могут использоваться идентификаторы чатов в формате почтовых адресов вида `<идентификатор>@chat-id.internal`.
Данный идентификатор подставляется в поле `to` при вызове API отправки сообщения.

Получить идентификатор чата можно следующими путями:

* Вариант 1: Скрытая команда, публичный ответ
  * Пользователь должен быть администратором чата. В случае с личными чатами, пользователь всегда администратор.
  * Пользователь отправляет команду `/_address` с упоминанием бота, таким образом: `@genie_bot /_address`.
  * В ответ бот напишет идентификатор, который можно использовать для отправки сообщений в этот чат. Идентификатор будет виден всем.
    * _Воспользоваться идентификатором для отправки можно только при использовании авторизации в API бота. Нет смыслка скрывать его._
* Вариант 2: Режим разработчика
  * Любой пользователь чата включает в клиенте режим разработчика:
    * _Меню -> **о программе** -> 10+ кликов на **иконку приложения** -> вкладка **Общее** -> включить пункт **Инфо для разработчика в меню сообщения** -> закрыть **крестиком** в верхнем правом углу_
  * Нажать правой кнопкой мыши в интересующем чате по любом существующему там сообщению (**нужно использовать сообщения внутри чата, а не внутри обсуждений!**) и выбрать пункт **инфо для разработчика**.
  * В появившемся меню найти параметр `groupChatId`с UUID-идентификатором в значении и скопировать значение.
  * Добавить к значению суффикс `@chat-id.internal`, получив что-то вроде `11112222-3333-4444-5555-666677778888@chat-id.internal`, получив значение, которое можно указывать в поле `to` при отправке запроса к API

## Команды бота

Бот реагирует на команды `/mute`, `/umute` и скрытую команду `/_address`.

Бот выполняет команду только в том случае, если её отправил администратор чата. В случае с личными чатами, пользователь всегда явдяется администратором.

В групповых чатах, в соответствии с рекомендациями по настройке бота (параметр _Доступные боту типы сообщений_: `commands`), отправлять боту команды требуется, сперва упомянув бота, например, `@genie_bot /mute`

Подробное описание команд:

* `/mute` - добавляет чат, в котором отправлена команда, в mute-список данного бота. Данный функционал требуется для того, чтобы пользователи или администратор чата мог отказаться от рассылки уведомлений в конкретный чат, например, на период отпуска или если данные уведомления ему не нужны, а технической возможности исключить его из рассылки - нет. Для клиента API поптки отправки сообщения:
  * с подтверждением доставки БУДУТ заканчиваться ответом HTTP `451`.
  * без подтверждения доставки МОГУТ заканчиваться ответом HTTP `451`, но могут и так же успешно рапортовать кодом `201` что сообщение принято в обработку.
* `/unmute` - удаляет чат, в котором отправлена команда, из mute-списка бота.
* `/_address` - указывает боту сообщить в чат, в котором был отправлена команда, идентификатор, который может использоваться отправки сообщений через API в данный чат.

## Установка бота как Docker контейнера из Docker Hub

Учти что таких ботов может быть несколько. В примере указывается имя `Genie` (`Джинни`) как имя бота.

### Создание и настройка бота

Для начала создай бота в админке eXpress. Пример:

* App ID: `genie_bot`
* URL: `http://docker-bot-server.example.com:8001/botapi` - здесь важно указать `/botapi`. Порт выбирай свободный.
* Имя: `🧞 Джинни`
* Описание: `Джинни`
* Включено: `Да`
* Версия протокола: `4`
* Остальное - по желанию

**Сохраняем**. Возвражаемся к списку ботов и открываем нашего бота на редактирование. Поправим раздел **Свойства бота**:

* Доступные боту типы сообщений: `commands`
* Кому разрешен доступ к боту: `local` или `trust`
* Кому разрешен поиск бота: `local`
* Разрешить создавать чаты: `Да`

**Сохраняем**. Снова открываем нашего бота на редактирование в самом верху переписываем значения `ID` и `Секретный ключ`.

### Установка бота на сервер

#### Клонирование репозитория и подготовка папок

Подразумевается что у тебя уже установлен `docker` на сервере. Если нет - посмотри на сайте `docker`, как его установить.
На сервере создай папку для бота, например `/opt/sendyxmail-genie` и склонируй в нее репозиторий [sendyxmail-docker-compose](https://github.com/go-botx/sendyxmail-docker-compose). Создай папку `certs` и `mutes`

```sh
mkdir -p /opt/sendyxmail-genie
cd /opt/sendyxmail-genie
wget https://github.com/go-botx/sendyxmail-docker-compose/archive/refs/heads/main.zip -qO- | unzip -j -
mkdir -p mutes certs
```

#### Редактирование конфигов

Отредактируй файл `sendyxmail.env`:

* Значение `BOT_CREDENTIALS` нужно сформировать из данных об имени сервера, ID и секретного ключа бота (уже созданного), разделив `@`, например: `ctshost.example.com@11111111111111111111111111111111@11111111-1111-1111-1111-111111111111`
* Значение для `METADATA_SECRET` нужно сгенерировать. Рекомендуется 30 символов, без спецсимволов. Можно сделать это онлайн, например, на сайте [pinetools](https://pinetools.com/random-string-generator) или [Random-Required](https://coddec.github.io/Random-Required/).

Отредактируй файл `tokens.yml`.
Здесь нужно добавить токены, которыми к боту будут обращаться отправители.

Формат такой, что нужен список объектов с полем token. Все остальные поля - опциональные и рекомендую оставить просто для себя, чтобы помнить, куда передавался тот или иной токен.

```yaml
- token: "значение1"
  опциональноеПоле: "значение"
- token: "значение2"
```

#### Установка доверия к сертификатам

Если на CTS сервере используется какой-то необычный сертификат HTTPS, например, выпущенный внутренним ЦС, необходимо добавить корневой сертификат этого внутреннего ЦС в доверие внутри контейнера. Возьми сертификат ЦС в формате PEM\base64 и положи его в папку `certs`

#### Про папку mutes

Бот хранит список за-mute-ных чатов в файле `mutes\mutes.txt`.
При изменении списка, бот сперва делает резервную копию файла  в `mutes\mutes.txt.mmbak`, затем сохраняет измененный список mute-ов во временный файл в папке `mutes`, затем копирует данные временного файла в `mutes\mutes.txt`.

Боту требуются права на создание новых файлов и удаление старых файлов в этой папке.

Скорее всего, решение с хранением в файле будет переделано на хранение в базе данных Postgres в будущем.

### Запуск

Запуск контейнеров

```sh
docker compose pull
docker compose up -d
```

### Добавление\Удаление токенов

Файл `tokens.yml` перечитывается раз в 10 минут.

## Диагностика

### Информация об отправителе

Каждое сообщение сожержит метаданные `encrypted_caller_info`. Это JSON, содержащий:

* Контрольную сумму Adler32 использованного токена
* IP-адреса отправителя, определенные сервером

Выглядит как:

```json
{
  "token_adler32": 3714782757,
  "caller_addr": "127.0.0.1",
  "caller_addrs": []
}
```

Данные зашифрованы с помощью производной от значения `METADATA_SECRET`. Чтобы получить данные, включи режим разработчика в клиенте. Затем нажми ПКМ на интересующем сообщении и выбери `Информация для разработчика`. Интерусующее тебя значение - в `object.payload.event.metadata.encrypted_caller_info`. Чтобы расшифровать значение, тебе нужно знать значение `METADATA_SECRET` на сервере бота. Пример расшифровки сообщения на **PowerShell 7+** находится в файле [decrypt_caller_info.ps1](scripts/decrypt_caller_info.ps1).

## Сборка из исходников

### Сборка приложения

Сборка просто работает.

```sh
go build .
```

### Сборка Docker Image

```sh
cd docker/docker-compose
docker compose build
```
